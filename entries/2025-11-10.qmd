---
title: "2025-11-10"
format:
  html: default
  pdf: default
params:
  course: "mc501"
  word_min: 450
  word_max: 500
  p1: 'Think about a variable you’ve seen reported often—something like income, grades, or social media followers. Was it reported as an average (mean)? Do you think that number accurately reflected the “typical” case? Based on what you learned in this chapter, would another measure of central tendency (median or mode) have been more appropriate? Why?'
 
---

## Choose **one** prompt to answer

> **Prompt A:** `r params$p1`


---

## Response

<!-- RESPONSE-START -->
Most of the time when I see grades posted or talked about, the average grade is the data that is offered. As stated in this week’s chapter, “The great strength of the Mean is also its primary weakness: its sensitivity to every score”. Without removing the dataset’s extreme outliers, most likely an inordinately low grade, the info you’re left with may not give a true representative of the full dataset. In the opposite direction, a few high grades may skew the average data to make students appear to be doing “better” than the actual dataset may yield. In either case, the “typical” results may not be reflected correctly when only giving average.

I believe that showing the Median grade would be a better representation of the actual state of the class. Given that the Median measurement has the built-in resistant measure, the extreme outliers would not have an outsized impact on the summation of the dataset. Looking back on the chapter, the Median does give a more accurate representation of the “typical” student’s performance. It would be appropriate to also consider Mode when giving an overview of student grades by finding the most frequently occurring grade. Presenting the Mode of a class’ grades is useful if many students receive the same grade. 

So far in this entry, I’ve been using the example of grades in a class. We have established that the Median would most likely be the best representative of a given class. However, it would be helpful to conceptualize other use cases for the various measures of central tendency. Not to knock Mean, because there are useful cases where the data is roughly symmetrical with no extreme outliers: average income within a small group of employees with similar jobs, temperature readings, and sports stats like batting averages. Since the Mean uses all of the data, it is sensitive to every value. This is great for accuracy when data is balanced, but troublesome when those extreme outliers exist.

Since it’s been quite some time since I've personally and intentionally used data summation methods like Mean, Median and Mode, this journal entry is a good refresher on the basics of these measures of central tendency. Since we’ve established that Median gives a truer picture of the “typical” observation, it’s important to remember that it works best with skewed or unevenly distributed data or when there are extreme outliers. Median seems to work well with financial info like household income and home prices. Since a few very rich people can raise the Mean, the Median income shows what a “typical” person earns. Real estate listings often use Median price to represent the market better than the mean.

Finding and displaying the Mode is useful when you want to know what’s popular or most typical in terms of frequency. Showing the Mode of survey results gives the most common answer to a question. You can also use it in demographics to see the most common age group in a sample.
<!-- RESPONSE-END -->

---

## Word Count & Range Check

```{r}
#| echo: false
#| message: false
#| warning: false
get_response_text <- function() {
  f <- knitr::current_input()
  if (is.null(f) || !file.exists(f)) return("")
  x <- readLines(f, warn = FALSE)
  # Find the lines that EXACTLY match the start/end markers
  s <- grep("^<!-- RESPONSE-START -->$", x)
  e <- grep("^<!-- RESPONSE-END -->$", x)
  if (length(s) != 1 || length(e) != 1 || e <= s) return("")
  paste(x[(s + 1L):(e - 1L)], collapse = "\n")
}
count_words <- function(txt) {
  # Remove code blocks and inline code before counting
  txt <- gsub("```[\\s\\S]*?```", " ", txt, perl = TRUE)
  txt <- gsub("`[^`]*`", " ", txt, perl = TRUE)
  # Keep letters, numbers, spaces, hyphens, and apostrophes
  txt <- gsub("[^\\p{L}\\p{N}\\s'-]", " ", txt, perl = TRUE)
  # Split by whitespace and count non-empty words
  words <- unlist(strsplit(txt, "\\s+", perl = TRUE))
  words <- words[nzchar(words)]
  length(words)
}
txt <- get_response_text()
n <- count_words(txt)
minw <- as.integer(params$word_min)
maxw <- as.integer(params$word_max)
in_range <- n >= minw && n <= maxw
cat(sprintf("**Word count:** %d  \n", n))
cat(sprintf("**Required range (%s):** %d–%d words  \n",
            toupper(params$course), minw, maxw))
cat(if (in_range) "**Status:** ✅ In range\n" else "**Status:** ❌ Out of range\n")
```
